\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{lipsum}
\usepackage{listings-rust}

% Define colors for the code listing
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configure the appearance of code listings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{1cm} 

    \Huge 
    \textbf{Hands-On 1 - Report} 

    \vspace{0.5cm} 

    \Large 
    Giuseppe Di Palma - 635525

    \vfill 

    \includegraphics[width=0.6\textwidth]{images/Cuddlyferris.png} 

    \vfill

    \Large 
    \today 
\end{titlepage}

\newpage

\section{Introduction}
In this report, we will evaluate how the functions \texttt{is\_bst} and \texttt{max\_leaf\_path} are implemented. 
The goal is to verify that the \texttt{is\_bst} function correctly identifies whether the tree is a valid Binary Search Tree (BST) and that \texttt{max\_leaf\_path} accurately calculates the maximum value of any path between two different leaf nodes.

\subsection{Tree and Node Implementation}
The binary tree is represented using a vector of \texttt{Node} structs, where each node has a key and optional left and right child indices. The \texttt{Tree} struct contains the non-empty vector of nodes. When the tree is created, it is required to specify the root key.

\section{Function is\_bst}
The \texttt{is\_bst} function verifies if the tree is a Binary Search Tree (BST). A tree is a BST if every node satisfies the following conditions:
\begin{itemize}
    \item The subtrees rooted at the left and right children are both BSTs;
    \item The maximum key in the subtree rooted at the left child is less than the node's key;
    \item The minimum key in the subtree rooted at the right child is greater than or equal to the node's key.
\end{itemize}

The function uses a recursive helper function, \texttt{rec\_is\_bst}, which traverses the tree and checks the BST properties at each node.

\begin{lstlisting}[language=Rust, style=boxed, caption=The \texttt{is\_bst} Function]
pub fn is_bst(&self) -> bool {
    self.rec_is_bst(Some(0)).0
}

fn rec_is_bst(&self, node_id: Option<usize>) -> (bool, Option<u32>, Option<u32>) {
    if let Some(id) = node_id {
        assert!(id < self.nodes.len(), 'Node id is out of range');
        let node = &self.nodes[id];

        let (is_left_bst, min_left, max_left) = 
            self.rec_is_bst(node.id_left);
        let (is_right_bst, min_right, max_right) = 
            self.rec_is_bst(node.id_right);

        if !is_left_bst || !is_right_bst {
            return (false, None, None);
        }

        match (min_left, max_left, min_right, max_right) {
            (None, None, None, None) => 
                return (true, Some(node.key), Some(node.key)),
            (None, None, Some(min_right), Some(max_right)) 
                if min_right >= node.key => 
            {
                return (true, Some(node.key), Some(max_right));
            }
            (Some(min_left), Some(max_left), None, None) 
                if max_left < node.key => 
            {
                return (true, Some(min_left), Some(node.key));
            }
            (Some(min_left), Some(max_left),
             Some(min_right), Some(max_right))
                if max_left < node.key && min_right >= node.key =>
            {
                return (true, Some(min_left), Some(max_right));
            }
            _ => {
                return (false, None, None);
            }
        }
    }

    (true, None, None)
}
\end{lstlisting}

The first thing \texttt{is\_bst} does is verify that both the subtrees rooted at the left and right children of the nodes are BSTs.\\
If this is not the case, the tree is not a BST, and the function returns false.\\
If both subtrees are BSTs, the function proceeds to verify the other two properties explained above, in the various cases:
\begin{itemize}
    \item If the node is a leaf, it is a BST with both the minimum and maximum value equal to the node's key.
    \item If the node has only the right child, the node's key should be less than or equal to the minimum key in the child BST.
    \item If the node has only the left child, the node's key should be greater than the maximum key in the child BST.
    \item If the node has both children, the node's key should be greater than the maximum key in the left child BST and less than or equal to the right child BST.
\end{itemize}
If none of these conditions are satisfied, the tree is not a BST, and the function returns false.
\\
In terms of efficiency, this function performs a post-order traversal, resulting in a time complexity of \(O(n)\), where \(n\) is the number of nodes.

\newpage

\section{Function max\_leaf\_path}
The \texttt{max\_leaf\_path} function computes the maximum sum of a simple path that starts from one leaf and ends at a different leaf. This function is often used to find the "heaviest" path in a binary tree.

The function relies on a recursive helper function \texttt{rec\_max\_leaf\_path}, which computes both the maximum path sum passing through a node and the maximum sum ending at a node.

\begin{lstlisting}[language=Rust, style=boxed, caption=The \texttt{max\_leaf\_path} Function]
pub fn max_leaf_path(&self) -> Option<u32> {
    match self.rec_max_leaf_path(Some(0)) {
        (Some(best), _) => Some(best),
        _ => None,
    }
}

fn add(&self, a: Option<u32>, b: Option<u32>) -> Option<u32> {
    match (a, b) {
        (Some(a), Some(b)) => Some(a.add(b)),
        (_, _) => None,
    }
}

fn rec_max_leaf_path(&self, node_id: Option<usize>) -> (Option<u32>, Option<u32>) {
    if let Some(id) = node_id {
        assert!(id < self.nodes.len(), 'Node id is out of range');
        let node = &self.nodes[id];

        let (best_left, max_left) = 
            self.rec_max_leaf_path(node.id_left);
        let (best_right, max_right) = 
            self.rec_max_leaf_path(node.id_right);

        let best_node = 
            self.add(self.add(max_left, max_right), Some(node.key));
        let best = best_left.max(best_right.max(best_node));
        let max = self.add(max_left.max(max_right), Some(node.key));

        if max.is_none() {
            return (best, Some(node.key));
        } else {
            return (best, max);
        }
    }
    (None, None)
}
\end{lstlisting}

The \texttt{rec\_max\_leaf\_path} function begins by making a recursive call over the left and right child nodes. The best value (the value of the heaviest path in the subtree rooted at the node) is evaluated as the maximum between the best values of the subtrees rooted at the node's children and the value of the heaviest path passing through the node.
We can see how the longest path passing through the node is evaluated using the \texttt{add} function, which allows safe summation operations over Option$<$u32$>$ values.
This is essential because a node may have one child, both children, or be a leaf.

The maximum value represents the heaviest path between a leaf and the node. It is evaluated by adding the node's key to the maximum between \texttt{max\_left} and \texttt{max\_right}. If both \texttt{max\_left} and \texttt{max\_right} are None (i.e., the node is a leaf), then the maximum value is simply the node key.

In terms of efficiency, the \texttt{rec\_max\_leaf\_path} function also performs a post-order traversal, resulting in a time complexity of \(O(n)\).

\end{document}